#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
//指针的自增和自减
int main()
{
	int a = 10;
	int* p;
	p = &a;
	printf("a的值:%d\n",a);//输出a的值为10
	printf( "a的地址:%d\n", &a);
	printf("p的值:%d\n", p);//p的值代表的是a的地址
	printf("*p的值:%d\n", *p);//*p代表的是p地址中的数，10
	//*p，*后面跟的是哪个变量的地址，*p代表的就是那个变量本身

	printf("%d\n",(*p)++);
	//输出的为10，相当于a++，先输出（*p）再++，等同于printf("%d\n",(*P));  (*p)++;
	printf("a的值:%d\n", a);//输出a的值为11,经过上面的自加运算后结果
	printf("a的地址:%d\n", &a);//地址不变
	printf("p的值:%d\n", p);//p的值代表的是a的地址
	printf("*p的值:%d\n", *p);//*p代表的是p地址中的数，11

	printf("%d\n", ++(*p));
	//相当于++a，先自加后输出，12
	printf("a的值:%d\n", a);//输出a的值为12,经过上面的自加运算后结果
	printf("a的地址:%d\n", &a);//地址不变
	printf("p的值:%d\n", p);//p的值代表的是a的地址
	printf("*p的值:%d\n", *p);//*p代表的是p地址中的数，12

	printf("%d\n", ++*p);
	//由于自加符号“++”，和指针运算符“*”，都是第二级运算级别，且此级别运算方向为：从右向左，所以 ++*p 先执行*p运算，再进行自加运算，故其相当于++(*p)，13
	printf("a的值:%d\n", a);//输出a的值为13,经过上面的自加运算后结果
	printf("a的地址:%d\n", &a);//地址不变
	printf("p的值:%d\n", p);//p的值代表的是a的地址
	printf("*p的值:%d\n", *p);//*p代表的是p地址中的数，13

	printf("%d\n", *p++);
	//由上面可知两运算符号优先级相同，故其从右向左进行运算，而()++的运算是先进行输出，后进行自加，所以此时输出的仍是*p，与上面的值相同，为13，
	//而后面的++运算是对p进行的，p本为对a的地址进行表示，p+1表示指向的地址偏移1个存储单元，p=p+1；和*(p++)代表同一个意思
	printf("a的值:%d\n", a);//输出a的值为13,表示的是上面a内的值
	printf("a的地址:%d\n", &a);//a的地址不变
	printf("p的值:%d\n", p);//此时p的值代表的是a后面单元的一个地址，由于a为int型，所以占4个字节，后一个地址要在a的地址上加4
	printf("*p的值:%d\n", *p);//*p代表的是a后面的一个存储单元中地址代表的数，但是在编码中并没有对这个地址进行声明，他是不确定的地址，所以指针p变成了野指针，结果出错
	return 0;
}
